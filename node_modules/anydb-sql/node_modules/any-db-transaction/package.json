{
  "name": "any-db-transaction",
  "version": "2.2.2",
  "description": "Transaction object for Any-DB adapters",
  "main": "transaction.js",
  "dependencies": {
    "inherits": "~2.0.1",
    "yafsm": "0.0.0",
    "once": "~1.3.0"
  },
  "devDependencies": {
    "any-db-postgres": "~2.1.0",
    "any-db-sqlite3": "~2.1.0",
    "any-db-mysql": "~2.1.0",
    "tape": "~2.3.2",
    "any-db-fake": "~0.0.3",
    "any-db-adapter-spec": "~2.1.0",
    "assert-in-order": "0.0.1",
    "covert": "~0.2.0"
  },
  "scripts": {
    "test": "tape tests/*.js",
    "covert": "covert tests/*.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/grncdr/node-any-db-transaction.git"
  },
  "keywords": [
    "any-db",
    "transaction",
    "sql"
  ],
  "author": {
    "name": "Stephen Sugden",
    "email": "me@stephensugden.com"
  },
  "license": "BSD-2-Clause",
  "bugs": {
    "url": "https://github.com/grncdr/node-any-db-transaction/issues"
  },
  "readme": "# any-db-transaction\n\n[![Build Status](https://travis-ci.org/grncdr/node-any-db-transaction.png)](https://travis-ci.org/grncdr/node-any-db-transaction)\n\nA simple transaction helper for [any-db][] compliant database adapters.\n\n## Synopsis\n\n```javascript\nvar anyDB = require('any-db')\nvar begin = require('any-db-transaction')\n\nvar connection = anyDB.createConnection(...)\n\n// Callback-style\nbegin(connection, function (err, transaction) {\n  if (err) return console.error(err)\n  // Do work using transaction\n  transaction.query(...)\n  transaction.commit()\n})\n\n// Synchronous-style*\nvar transaction = begin(connection)\ntransaction.on('error', console.error)\ntransaction.query(...)\ntransaction.commit()\n\n// Or use a connection pool\nvar pool = anyDB.createPool(...)\nvar transaction = begin(pool)\n```\n\n## API\n\n```ocaml\nmodule.exports := begin(Queryable, statement: String?, Continuation<Transaction>?) => Transaction\n\nTransaction := FSM & Queryable & {\n  commit:   (Continuation?) => void\n  rollback: (Continuation?) => void\n}\n```\n\n### begin\n\n```ocaml\nmodule.exports := begin(Queryable, statement: String?, Continuation<Transaction>?) => Transaction\n```\n\nTransaction objects are are simple wrappers around a [Connection][] that also\nimplement the [Queryable][] API, but guarantee that all queries take place\nwithin a single database transaction or not at all. Note that `begin` also\nunderstands how to acquire (and release) a connection from a [ConnectionPool][]\nas well, so you can simply pass a pool to it: `var tx = begin(pool)`\n\nBy default, any queries that error during a transaction will cause an automatic rollback.\nIf a query has no callback, the transaction will also handle (and re-emit)\n`'error'` events for the [Query][] instance. This enables handling errors for\nan entire transaction in a single place.\n\nTransactions may also be nested by passing a `Transaction` to `begin` and these\nnested transactions can safely error and rollback without rolling back their\nparent transaction:\n\n```javascript\nvar parent = begin(connection)\nvar child = begin(parent)\nchild.query(\"some invalid sql\")\nchild.on('error', function () {\n  parent.query(\"select 1\") // parent still works\n})\n```\n\nThis feature relies on the `SAVEPOINT` support in your database. (In particular\nMySQL will doesn't have good support in very old versions). The use of\nsavepoints also means there is no option to replace the statement used to begin\nthe child transaction.\n\nWhile the child transaction is in progress the parent transaction will queue any\nqueries it receives until the child transaction either commits or rolls back, at\nwhich point it will process the queue. Be careful: it's quite possible to write\ncode that deadlocks by waiting for a query in the parent transaction before\ncommitting the child transaction. For example:\n\n```javascript\n// Do not do this! it will deadlock!\n\nvar parent = begin(connection) // starts the transaction\nvar child  = begin(parent)     // creates a savepoint\n\nparent.query('SELECT 1', function (err) {\n  child.commit();\n});\n```\n\n\n#### Automatic Rollback on Error\n\nAs stated previously, by default any queries that error during a transaction\nwill cause an automatic rollback. This is to support the common pattern in which\na transaction is a series of queries you either want to succeed or fail\natomically.\n\nThere is another common pattern for transactions where you either create or\nupdate a record. Many databases support an `INSERT OR REPLACE` statement, but\nquite often you'd like an `INSERT OR UPDATE` construct instead.\n\nIntuitively, a transaction can be used for this as well:\n\n1. Start a transaction\n1. Try an insert statement\n - If that succeeds, commit.\n - Otherwise, continue\n1. Try an update statement.\n  - If that succeeds, commit.\n  - Otherwise, roll back the transaction.\n\nA transaction is unlikely to be the best choice here. The results of the first\nstatement need to make it back to the client before it can decide whether to\ncommit or try something else. Usually databases better support this kind of\nconstruct with nested queries, which avoid those roundtrips.\n\nTo facilitate this kind transaction use, automatic rollback of transactions\ncan be disabled.\n\n```javascript\nvar tx = begin(conn, {autoRollback: false});\ntx.query('Query that produces errors', function(err) {\n    tx.query('another query');\n});\n```\n\n**Note**: PostgreSQL does not allow you to use a transaction immediately after\nan error. However, you can get much the same behaviour by explicitly adding\n`SAVEPOINT` statements. A transaction with an error can be rolled back to a\nknown good savepoint, and can be used from there onwards. You can achieve the\nsame by using nested transactions.\n\n```javascript\nvar tx = begin(conn, {autoRollback: false});\nvar sp = begin(tx);\nsp.query('query that might fail', function(err) {\n  if (err) {\n    tx.query('alternate queries');\n  } else {\n    sp.commit();\n  }\n});\n```\n\nNote that the failing query is performed on the \"savepoint\" child transaction,\nbut the final query is perfomed on the outer/parent transaction.\n\n### Transaction states\n\nTransactions are [FSM][] instances with 4 states: `disconnected`,\n`connected`, `open`, and `closed`:\n\n    [disconnected]\n          ↓\n     [connected]\n       ↓  ↓  ↑\n       ↓ [open]\n       ↓   ↓\n      [closed]\n\nEvery transaction starts out in the `disconnected` state, in which it will queue\nall tasks (queries, child transactions, commits and rollbacks) in the order they\nare received.\n\nOnce the transaction acquires a connection\\* it will transition to the\n`connected` state and begin processing it's internal task queue. While in this\nstate any new tasks will still be added to the end of the queue. There are two\npossible transitions from the `connected` state:\n\n * `connected → open` - When all queued tasks have finished.\n * `connected → closed` - When a rollback or commit is encountered in the queue.\n   This includes automatic rollbacks caused by query errors.\n\n`closed` is a terminal state in which all further database operations result in\nerrors. (The errors will either be sent to any callback provided or emitted as\n`error` events on the next tick).\n\nIn the `open` state, all database operations will be performed immediately. If\na child transaction is started like `var child = begin(parentTxn)`, the parent\ntransaction will move back into the `connected` state (queueing any queries it\nreceives) until the child completes, at which point it will resume processing\nit's own internal queue.\n\nTransactions created from a [Connection][] transition to `connected` before\n[begin][] returns.\n\n### Transaction.adapter\n\nThe [Adapter](https://github.com/grncdr/node-any-db-adapter-spec/#adapter) instance used by the resource (connection or parent transaction) underlying this transaction.\n\n### Transaction.query\n\n```ocaml\n(text: String, params: Array?, Continuation<Result>?) => Query\n```\n\nMaintains the same contract as [Queryable.query][] but adds further guarantees\nthat queries will be performed within the transaction or not at all. If the\ntransaction has been committed or rolled back this method will fail by passing\nan error to the continuation (if provided) or emitting an `'error'` event.\n\n### Transaction.commit\n\n```ocaml\n(Continuation<void>) => void\n```\n\nIssue a `COMMIT` (or `RELEASE ...` in the case of nested transactions) statement\nto the database. If a continuation is provided it will be called (possibly with\nan error) after the `COMMIT` statement completes. The transaction object itself\nwill be unusable after calling `commit()`.\n\n### Transaction.rollback\n\n```ocaml\n(Continuation<void>) => void\n```\n\nThe same as [Transaction.commit](#transactioncommit) but issues a `ROLLBACK`.\nAgain, the transaction will be unusable after calling this method.\n\n### Transaction events\n\n * `'query', query` - emitted immediately after `.query` is called on a\n   connection via `tx.query`. The argument is a [query](#query) object.\n * `'commit:start'`      - Emitted when `.commit()` is called.\n * `'commit:complete'`   - Emitted after the transaction has committed.\n * `'rollback:start'`    - Emitted when `.rollback()` is called.\n * `'rollback:complete'` - Emitted after the transaction has rolled back.\n * `'close'`             - Emitted after `rollback` or `commit` completes.\n * `'error', err`        - Emitted under three conditions:\n   1. There was an error acquiring a connection.\n   2. Any query performed in this transaction emits an error that would otherwise\n      go unhandled.\n   3. Any of `query`, `begin`, `commit`, or `rollback` are called after the\n      connection has already been committed or rolled back.\n\n   Note that the `'error'` event **may be emitted multiple times!** depending on\n   the callback you are registering, you way want to wrap it using [once][].\n\n## Examples\n\n### Unit-of-work middleware\n\nA common pattern in web applications is start a transaction for each request and\ncommit it before sending a response. Here is a simplified [connect][] middleware\nthat encapsulates this pattern:\n\n```javascript\nmodule.exports = function unitOfWorkMiddleware (pool, errorHandler) {\n  return function (req, res, next) {\n    req.tx = pool.begin()\n    // intercept writeHead to ensure we have completed our transaction before\n    // responding to the user\n    var writeHead = res.writeHead\n    res.writeHead = function () {\n       if (req.tx.state() != 'closed') {\n         req.tx.commit(function (err) {\n           if (err) {\n             errorHandler(req, res, err)\n           } else {\n             writeHead.apply(res, arguments)\n           }\n         })\n       } else {\n         writeHead.apply(res, arguments)\n       }\n    }\n    next()\n  }\n}\n```\n\n### Rolling back\n\nHere's an example where we stream all of our user ids, check them against an\nexternal abuse-monitoring service, and flag or delete users as necessary, if\nfor any reason we only get part way through, the entire transaction is rolled\nback and nobody is flagged or deleted:\n\n```javascript\nvar pool = require('any-db').createPool(...)\n\n// this is our external service\nvar abuseService = require('./services').abuseService()\n\nvar tx = begin(pool)\ntx.on('error', finished)\n\n/*\nWhy query with the pool and not the transaction?\nBecause it allows the transaction queries to begin executing immediately,\nrather than queueing them all up behind the initial SELECT.\n*/\npool.query('SELECT id FROM users')\n  .on('data', function (user) {\n    if (tx.state() == 'closed') {\n      // Do not make unneccessary requests\n      return\n    }\n    abuseService.checkUser(user.id, function (err, result) {\n      if (err) return tx.handleError(err)\n      // Errors from these queries will propagate up to the transaction object\n      if (result.flag) {\n        tx.query('UPDATE users SET abuse_flag = 1 WHERE id = $1', [user.id])\n      } else if (result.destroy) {\n        tx.query('DELETE FROM users WHERE id = $1', [user.id])\n      }\n    })\n  }).on('end', function () {\n    tx.commit(finished)\n  })\n\nfunction finished (err) {\n  if (err) console.error(err)\n  else console.log('All done!')\n}\n```\n\n# License\n\n2-clause BSD\n\n[any-db]: https://github.com/grncdr/node-any-db\n[begin]: #begin\n[Connection]: https://github.com/grncdr/node-any-db-adapter-spec#connection\n[Queryable]: https://github.com/grncdr/node-any-db-adapter-spec#queryable\n[Queryable.query]: https://github.com/grncdr/node-any-db-adapter-spec#queryablequery\n[Query]: https://github.com/grncdr/node-any-db-adapter-spec#query\n[ConnectionPool]: https://github.com/grncdr/node-any-db-pool#connectionpool\n\n[connect]: https://npm.im/connect\n",
  "readmeFilename": "README.md",
  "_id": "any-db-transaction@2.2.2",
  "dist": {
    "shasum": "3e304767254a35948aaa7664827b6189ba0cc090"
  },
  "_from": "any-db-transaction@^2.2.1",
  "_resolved": "https://registry.npmjs.org/any-db-transaction/-/any-db-transaction-2.2.2.tgz"
}
